package go_restful_routes

import (
	"crypto/md5"
	"errors"
	"fmt"
	"sort"
	"strings"
)

// routeItem
// key is a Hash generated by Pattern and HTTPMethods.
// The key acts not only as a key for RoutingTable.full, but also as a routes key for http.ServeMux.
type routeItem struct {
	HTTPMethods   []string    // request.Method
	Handler       handlerFunc // func(http.ResponseWriter, *http.Request)
	Pattern       string      // raw routes path pattern
	key           string      // MD5 hash
	patternBlocks []string    // split Pattern by `/`
	regex         string      // trim `{}` from path
	params        pathParams
}

// newRouteItem Include sorting the methods and filling the key.
func newRouteItem(pattern string, handler handlerFunc, methods []string) (*routeItem, error) {
	if pattern == "" {
		return nil, errors.New("[WARN] routing pattern cannot be empty")
	}
	item := &routeItem{Pattern: pattern, Handler: handler, HTTPMethods: methods}
	item.fillKey()
	return item, nil
}

// fillKey Calculate hash from path and http methods. Assign hash value to `item.key`.
func (item *routeItem) fillKey() *routeItem {
	bytes := []byte(item.Pattern)
	if len(item.HTTPMethods) > 0 {
		sort.Strings(item.HTTPMethods)
		for _, m := range item.HTTPMethods {
			bytes = append(bytes, m...)
		}
	}
	item.key = fmt.Sprintf("/%x", md5.Sum(bytes))
	return item
}

// validHTTPMethod empty slice means allow all
func (item *routeItem) validHTTPMethod(method string) bool {
	if len(item.HTTPMethods) == 0 {
		return true
	}
	for _, m := range item.HTTPMethods {
		if method == m {
			return true
		}
	}
	return false
}

func (item *routeItem) parsePatternBlocks() (err error) {
	blocks := strings.Split(strings.TrimRight(item.Pattern, "/"), "/")
	if len(blocks) < 1 {
		return errors.New(fmt.Sprintf("[WARN] routing pattern is invalid: %v", item.Pattern))
	}
	item.patternBlocks = blocks
	return nil
}
